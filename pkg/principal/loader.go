package principal

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"

	"gopkg.in/yaml.v3"

	"github.com/UiP9AV6Y/basic-oauth2/pkg/password"
	"github.com/UiP9AV6Y/basic-oauth2/pkg/utils"
)

const (
	HtpasswdSeparator  string = ":"
	EmailIndicator     string = "@"
	DefaultEmailDomain string = "localhost"
)

// GenerateEmail renders the input information as email address.
// If the ident does appear to be an email address already, the
// value is returned unchanged.
func GenerateEmail(ident, domain string) (string, bool) {
	if strings.Contains(ident, EmailIndicator) {
		return ident, true
	}

	return fmt.Sprint(ident, EmailIndicator, domain), false
}

type Loader struct {
	EmailVerified  bool
	EmailDomain    string
	valueProcessor utils.StringProcessor
}

func NewLoader(valueProcessor utils.StringProcessor) *Loader {
	loader := &Loader{
		EmailDomain:    DefaultEmailDomain,
		valueProcessor: valueProcessor,
	}

	return loader
}

// NewPassthroughLoader create a principal loader whose
// field post-processor is a noop/passthrough implementation.
func NewPassthroughLoader() *Loader {
	passthrough := func(s string) string {
		return s
	}
	loader := &Loader{
		EmailDomain:    DefaultEmailDomain,
		valueProcessor: utils.FunctorProcessor(passthrough),
	}

	return loader
}

// ParseMap extracts principal information from the provided key/values mapping.
// All fields are post-processed using the internal string processor.
func (l *Loader) ParseMap(data map[string]interface{}) ([]Principal, error) {
	principals := make(map[string]principalData, len(data))
	for k, v := range data {
		if m, ok := v.(map[string]interface{}); ok {
			p := &principalData{}
			if err := p.UnmarshalMap(m); err != nil {
				return nil, fmt.Errorf("malformed map entry %q: %w", k, err)
			}
			principals[k] = *p
		} else if s, ok := v.(string); ok {
			principals[k] = principalData{
				Password: s,
			}
		} else {
			return nil, fmt.Errorf("unsupported value format %q", k)
		}
	}

	return l.parseData(principals)
}

// ParseFile reads a file as YAML formatted data.
// All fields are post-processed using the internal string processor.
func (l *Loader) ParseFile(path string) ([]Principal, error) {
	yamlFile, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}

	principals := make(map[string]principalData)
	err = yaml.Unmarshal(yamlFile, principals)
	if err != nil {
		return nil, fmt.Errorf("unable to parse %q: %w", path, err)
	}

	return l.parseData(principals)
}

// ParseHtpasswd reads a file in the format
// generated by the Apache `htpasswd` utility.
// Empty lines and lines starting with # are ignored.
// All fields are post-processed using the internal string processor.
// See https://httpd.apache.org/docs/2.4/misc/password_encryptions.html#basic
func (l *Loader) ParseHtpasswd(path string) ([]Principal, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	lineNo := 0
	principals := []Principal{}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		lineNo++
		line := strings.TrimSpace(scanner.Text())
		if len(line) == 0 || line[0] == '#' {
			continue
		}

		principal, err := l.ParseLine(line)
		if err != nil {
			return nil, fmt.Errorf("%s (%d): %w", path, lineNo, err)
		}

		principals = append(principals, principal)
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return principals, nil
}

// Parse line splits the input using the HtpasswdSeparator
// and processes each available field.
// The fields are associated in the following order:
//  * Ident
//  * Password
//  * Email
//  * EmailVerified
func (l *Loader) ParseLine(line string) (Principal, error) {
	var ident string
	data := principalData{}
	fields := strings.Split(line, HtpasswdSeparator)

	if len(fields) > 0 {
		ident = fields[0]
	}

	if len(fields) > 1 {
		data.Password = fields[1]
	}

	if len(fields) > 2 {
		data.Email = fields[2]
	}

	if len(fields) > 3 {
		data.EmailVerified = fields[4]
	}

	return l.newPrincipal(ident, data)
}

func (l *Loader) parseData(m map[string]principalData) ([]Principal, error) {
	principals := make([]Principal, 0, len(m))

	for i, d := range m {
		principal, err := l.newPrincipal(i, d)
		if err != nil {
			return nil, err
		}

		principals = append(principals, principal)
	}

	return principals, nil
}

func (l *Loader) processPrincipalString(name, value string, field *string) error {
	v, err := l.valueProcessor.Process(value)
	if err != nil {
		return fmt.Errorf("malformed principal %s %q: %w", name, value, err)
	} else if v != "" {
		*field = v
		return nil
	} else if *field == "" {
		return fmt.Errorf("principal %s cannot be empty", name)
	}

	// leave value unchanged
	return nil
}

func (l *Loader) processPrincipalBool(name, value string, field *bool) error {
	v, err := l.valueProcessor.Process(value)
	if err != nil {
		return fmt.Errorf("malformed principal %s %q: %w", name, value, err)
	} else if v == "" {
		// leave value unchanged
		return nil
	}

	b, err := strconv.ParseBool(v)
	if err != nil {
		return fmt.Errorf("malformed principal %s %q: %w", name, v, err)
	}

	*field = b
	return nil
}

func (l *Loader) processPrincipalPassword(name, value string, field *password.Password) error {
	v, err := l.valueProcessor.Process(value)
	if err != nil {
		return fmt.Errorf("malformed principal %s %q: %w", name, value, err)
	} else if v == "" {
		// leave value unchanged
		return nil
	}

	p, err := password.ParsePassword(v)
	if err != nil {
		return fmt.Errorf("malformed principal %s %q: %w", name, v, err)
	}

	field.Value = p.Value
	field.Codec = p.Codec
	return nil
}

func (l *Loader) newPrincipal(ident string, m principalData) (Principal, error) {
	var verified bool
	principal := &DefaultPrincipal{}

	if err := l.processPrincipalString("ident", ident, &principal.Ident); err != nil {
		return nil, err
	}

	// calculate default values based on ident
	principal.Password = password.NewPlaintextPassword(principal.Ident)
	principal.Email, verified = GenerateEmail(principal.Ident, l.EmailDomain)
	principal.EmailVerified = verified || l.EmailVerified

	if err := l.processPrincipalString("email", m.Email, &principal.Email); err != nil {
		return nil, err
	}

	if err := l.processPrincipalBool("email verified", m.EmailVerified, &principal.EmailVerified); err != nil {
		return nil, err
	}

	if err := l.processPrincipalPassword("password", m.Password, principal.Password); err != nil {
		return nil, err
	}

	return principal, nil
}
